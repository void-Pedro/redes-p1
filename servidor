'''
Trabalho feito por:
    Pedro Henrique Borges - RA 804071
    
Passos feitos até o momento (ir atualizando conforme for fazendo): 1-4
'''


#!/usr/bin/env python3
import asyncio
from tcp import Servidor
import re
apelidosUsados = {}
canais = {}
dados_residuais = b''

def validar_nome(nome):
    return re.match(br'^[a-zA-Z][a-zA-Z0-9_-]*$', nome) is not None

def sair(conexao):
    print(conexao, 'conexão fechada')
    conexao.fechar()
    nick = usuarioConexao(conexao)
    if nick is None or nick == b'*':
        return
    
    for canal in canais:
        if nick.lower() in canais[canal.lower()]:
            msg = b':' + nick + b' QUIT :Connection closed' + b'\r\n'
            msgList(conexao, canal, msg)
            users = canais[canal].copy()
            users.remove(nick.lower())
            if users is None:
                canais.pop(canal.lower())
                apelidosUsados.pop(nick.lower())
                return
            
            # senão, só atualize os usuarios
            canais[canal.lower()] = users
    # removendo o usuario dos Nomes cadastrados
    apelidosUsados.pop(nick.lower())
    return


def dados_recebidos(conexao, dados):
    if dados == b'':
        return sair(conexao)
    
    dados = trataEntradas(conexao, dados)
    
    
    for dado in dados:
        comando = dado.split(b'', 1)[0]
        if comando == b'PING':
            cmdPing(conexao, dado)
        elif comando == b'NICK':
            cmdNick(conexao, dado)
        elif comando == b'PRIVMSG':
            destinatario, dest_msg = dado.split(b' :', 1)
            destinatario = destinatario.split(b' ')[1]
            msg = b':' + encontraUsuario(conexao) + b' PRIVMSG ' + destinatario + b' :' + dest_msg
            privMsg(conexao, destinatario, msg)
        elif comando == b'JOIN':
            cmdJoin(conexao, dado)
        elif comando == b'PART':
            cmdPart(conexao, dado)
            
    print(conexao, dados)


def conexao_aceita(conexao):
    print(conexao, 'nova conexão')
    conexao.dados_residuais = b''
    conexao.registrar_recebedor(dados_recebidos)

# Resolução do Passo 1
def cmdPing(conexao, dados):
    resposta = b':server PONG server :'
    resposta += dados.split(b'', 1)[1] # Resposta + payload
    conexao.enviar(resposta)

# Resolução do Passo 3/4
def cmdNick(conexao, dados):
    nickAntigo = usuarioConexao(conexao)
    nick = dados.split(b'', 1)[1]
    valido = validar_nome(nick)
    if not valido:
        conexao.enviar(b'server 432 apelido_atual apelido :Erroneous nickname')
        return
    else: 
        if(nick.lower() in apelidosUsados):
            conexao.enviar (b':server 433 ' + nickAntigo + b' ' + nick + b' :Nickname is already in use\r\n')
            return
        
        # Usuário não definiu o apelido ainda
        elif(nick.lower() not in apelidosUsados and nickAntigo == b'guest'):
            apelidosUsados[nick.lower()] = conexao
            conexao.enviar(b':server 001 ' + nick + b' :Welcome\r\n')
            conexao.enviar(b':server 422 ' + nick + b' :MOTD File is missing\r\n')
            return
        
        # Usuário quer trocar o apelido
        else:
            apelidosUsados[nick.lower()] = apelidosUsados.pop(nickAntigo.lower())
            conexao.enviar(b':' + nickAntigo + b' NICK ' + nick + b'\r\n')
            return

# Resolução do Passo 5
def privMsg(conexao, destinatario, mensagem):
    remetente = usuarioConexao(conexao)

    if destinatario.startswith(b'#'): # Se for canal
        comando = mensagem.split(b' ', 3)[1]
        usuarios = canais[canal.lower()].copy()
        if comando == b'PRIVMSG' or comando == b'QUIT':
            usuarios.remove(encontraUsuario(conexao).lower())
        for usuario in usuarios:
            privMsg(conexao, usuario, mensagem)
        return
    if destinatario.lower() not in apelidosUsados:
        return
    dest = usuarioConexao(destinatario.lower())
    dest.enviar(mensagem)
    return    
    
# Resolução do Passo 6
def cmdJoin(conexao, dados):
    canal = removeDado(dados)

    # Validando o nome do canal
    if (validar_nome(canal.split(b'#')[1]) is None) or canal[0] != 35:
        conexao.enviar(b':server 403 '  + canal + b' :No such channel\r\n')
        return
    
    usuario = usuarioConexao(conexao)
    if canal.lower() not in canais: # Se canal existe
        canais[canal.lower()] = [usuario]
    elif canal.lower() in canais: # Se não
        if usuario not in canais[canal.lower()]:
            var_user = canais[canal.lower()]
            var_user.append(usuario)
            var_user.sort()
            canais[canal.lower()] = var_user
            del var_user
        else:
            # Caso o usuario esteja no canal
            return

    msg = b':' + usuario + b' JOIN :' + canal + b'\r\n'
    privMsg(conexao, canal, msg)
    
    # Usuários do canal
    membros = canais[canal.lower()].copy()
    membros.sort()

    # Mensagem base a ser recortada para envio
    base = b':server 353 '+ usuario + b' = ' + canal + b' :'
    msg = base + membros[0]

    for i in range(1, len(membros)):
        membro = membros[i]
        if len(msg + membro + b' ' + b'\r\n') < 512:
            msg = msg + b' ' + membro
        else:
            conexao.enviar(msg + '\r\n')
            msg = base + b' ' + membro
    
    conexao.enviar(msg + b'\r\n')

    # Mensagem de servidor 366
    msg = b':server 366 ' + usuario + b' ' + canal + b' :End of /NAMES list.\r\n'
    conexao.enviar(msg)
   
    return  
    
def cmdPart(conexao, dados):
    canal = dados[0].split(b' ')[1]
    canal = canal.split(b'\r\n')[0]
    
    usuario = usuarioConexao(conexao)
    
    msg = b':' + usuario + b' PART ' + canal + b'\r\n'
    privMsg(conexao, canal, msg)
    
    usuarios = canais[canal.lower()]
    usuarios.remove(usuario.lower())
    canais[canal] = usuarios
    if canais[canal.lower()] is None:
        canais.pop(canal.lower())

# Resolução do Passo 2
def trataEntradas(conexao, dados):
    """
    Função criada para tratar as entradas. Situações suportadas:
        Uma mensagem do tipo "linha\r\n" pode ser quebrada em várias partes. Por exemplo, podemos receber primeiro "lin", depois "h" e depois "a\r\n".
        
        Duas ou mais mensagens podem ser recebidas de uma só vez. Por exemplo, podemos receber "linha 1\r\nlinha 2\r\nlinha 3\r\n".
        
        As duas coisas também podem acontecer ao mesmo tempo. Podemos receber, por exemplo, algo do tipo "a 1\r\nlinha 2\r\nli".
    """
    if conexao.dados_residuais != b'':
        dados = conexao.dados_residuais + dados
        conexao.dados_residuais = b''
    
    # Verifica se existe um comando "completo" nos dados
    if b'\n' in dados:
        dados = dados.split(b'\n')
        for i in range(len(dados) - 1):
                dados[i] = dados[i] + b'\n'
        if dados[-1] != b'\n':
            conexao.dados_residuais = dados[-1]
            dados[-1] = b''
    else: # Último comando incompleto
        conexao.dados_residuais = conexao.dados_residuais + dados
        dados = []
    return dados

# Função auxiliar para encontrar o nick do usuário baseado na conexão
def usuarioConexao(conexao):
    for chave, valor in apelidosUsados.items():
        if conexao == valor:
            return chave
    return b'guest'

servidor = Servidor(6667)
servidor.registrar_monitor_de_conexoes_aceitas(conexao_aceita)
asyncio.get_event_loop().run_forever()
